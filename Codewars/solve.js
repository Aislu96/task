function solve(str, idx) {
    let value = 0;
    if (str[idx] !== '(') return -1;
    for (let i = idx + 1; i < str.length; i++) {
        if (str[i] === '(') {
            value += 1;
        } else if (str[i] === ')' && value !== 0) {
            value += -1;
        } else if (str[i] === ')' && value == 0) {
            return i;
        }
    }
}

solve("((1)23(45))(aB)", 0)
solve("((1)23(45))(aB)", 1)
solve("((1)23(45))(aB)", 2)
solve("((1)23(45))(aB)", 6)


//В этом ката вам будет предоставлена ​​строка со скобками и индекс открывающей скобки, и вашей задачей будет вернуть индекс соответствующей закрывающей скобки. И входной, и возвращаемый индекс отсчитываются от 0, за исключением Фортрана, где он отсчитывается от 1 . Открывающая скобка всегда будет иметь закрывающую скобку. Возврат -1, если ответа нет (в Haskell возврат Nothing; в Фортране возврат 0; в Go возврат ошибки)
//
// Примеры
// solve("((1)23(45))(aB)", 0) = 10 // the opening brace at index 0 matches the closing brace at index 10
// solve("((1)23(45))(aB)", 1) = 3
// solve("((1)23(45))(aB)", 2) = -1 // there is no opening bracket at index 2, so return -1
// solve("((1)23(45))(aB)", 6) = 9
// solve("((1)23(45))(aB)", 11) = 14
// solve("((>)|?(*'))(yZ)", 11) = 14
// Ввод будет состоять из букв, цифр и специальных символов, но без пробелов. Единственными скобками будут (и ).
//
// Больше примеров в тестовых примерах.
//
// Удачи!
